#' Donor returns search
#'
#' @param donor_name donor name
#' @param approximate logical. If \code{TRUE}, will use \code{agrep} for searching rather than grep.
#'
#' @return A \code{data.frame}.
#' @export
donor_returns_search <- function(donor_name, approximate = FALSE) {

  tmp_groups <- unique(returns_party[c("ClientFileId", "PartyGroupId", "PartyGroupName")])

  if(approximate == FALSE) {
    return_data <- returns_donor_details[grep(donor_name, returns_donor_details$ReturnClientName),]
  } else {
    return_data <- returns_donor_details[agrep(donor_name, returns_donor_details$ReturnClientName),]
  }
  return_data <- merge(return_data, tmp_groups, by.x = "DonationMadeToClientFileId", by.y = "ClientFileId", all.x = TRUE)
  colnames(return_data) <- gsub("DonationMadeToName", "RecipientName", colnames(return_data), fixed = TRUE)
  colnames(return_data) <- gsub("ReturnClientName", "DonorName", colnames(return_data), fixed = TRUE)

  return_data <- return_data[c("FinancialYear", "RecipientName", "DonorName", "PartyGroupName", "TransactionDate", "Amount")]
  rownames(return_data) <- NULL
  return(return_data[order(return_data$FinancialYear, return_data$PartyGroupName, return_data$RecipientName, decreasing = TRUE),])

}

#' Recipient returns search
#'
#' @param donor_name Donor name
#' @param approximate logical. If \code{TRUE}, will use \code{agrep} for searching rather than grep.
#'
#' Includes political party, political campaigner and associated entity returns.
#'
#' @return A \code{data.frame}.
#' @export
recipient_returns_search <- function(donor_name, approximate = FALSE) {

  if(approximate == FALSE) {
    return_data <- returns_receipts_details[grep(donor_name, returns_receipts_details$ReceivedFromClientName),]
  } else {
    return_data <- returns_receipts_details[agrep(donor_name, returns_receipts_details$ReceivedFromClientName),]
  }
  # colnames(return_data) <- gsub("Value", "Amount", colnames(return_data), fixed = TRUE)
  colnames(return_data) <- gsub("ReceivedFromClientName", "DonorName", colnames(return_data), fixed = TRUE)
  rownames(return_data) <- NULL
  return_data[c("FinancialYear", "ReturnTypeDescription", "DonorName", "RecipientName", "PartyGroupName", "ReceiptType", "Amount")]

}

donor_id_search <- function(donor_name) {

  tmp_donor <- returns_donor[c("FinancialYear", "CurrentClientName", "ReturnClientName", "ClientFileId")][grepl(donor_name, returns_donor$CurrentClientName) | grepl(donor_name, returns_donor$ReturnClientName),]
  tmp_donor$ReturnType <- "Donor Return"
  tmp_donor <- unique(tmp_donor)

  tmp_recip <- returns_receipts_details[c("FinancialYear", "ReceivedFromClientName", "ReceivedFromClientId", "ReturnTypeDescription")][grepl(donor_name, returns_receipts_details$ReceivedFromClientName),]
  colnames(tmp_recip) <- c("FinancialYear", "ReturnClientName", "ClientFileId", "ReturnType")
  tmp_recip$CurrentClientName <- NA
  tmp_recip <- unique(tmp_recip)

  rbind(tmp_donor, tmp_recip)

}

#' Search donor and recipient returns for the named donor(s).
#'
#' This provides a quick way to search for named donors in either the donor
#' returns or the donor and recipient returns.
#'
#' The search is via a string search (using either \code{grep} or
#' \code{agrep}, depending on arguments) of the \code{DonorName} field. As
#' such, the \code{donor_name} argument supports regular expressions.
#'
#' If the \code{donor_only} argument is \code{FALSE}, the function also
#' searchers the recipient returns, which is good from the sake of
#' completeness, but also includes 'Other Receipts' (ie., receipts which
#' are not donations), which may lead to interpretation difficulties.
#'
#' The companion function \code{returns_search_summary()} provides the
#' output of this function aggregated by donor name (and optionally by
#' year).
#'
#' @param donor_name Donor name as a regular expression.
#' @param approximate (\code{BOOL}) If \code{TRUE}, use \code{agrep} for an
#'   appoximate match, rather than \code{grep}. Defaults to \code{FALSE}
#'   (\code{grep}).
#' @param donor_only (\code{BOOL}) Only search donor returns (useful for
#'   avoiding 'Other Receipts' in recipient returns). Defaults to
#'   \code{TRUE}.
#'
#' @return A \code{data.frame}.
#' @export
#'
#' @examples
#' returns_search("Woodside|AGL")
returns_search <- function(donor_name, approximate = FALSE, donor_only = TRUE) {

  tmp_groups <- unique(returns_party[c('ClientFileId', 'PartyGroupId', 'PartyGroupName')])

  tmp_common_cols <- c('FinancialYear', 'ReturnId', 'RegistrationCode',
                       'DonorName', 'RecipientName', 'PartyGroupName',
                       'ReceiptType', 'ReturnTypeDescription', 'TransactionDate', 'Amount')

  if(approximate == FALSE) {
    tmp_donor <- returns_donor_details[grep(donor_name, returns_donor_details$ReturnClientName),]
  } else {
    tmp_donor <- returns_donor_details[agrep(donor_name, returns_donor_details$ReturnClientName),]
  }

  tmp_donor <- merge(tmp_donor, tmp_groups, by.x = "DonationMadeToClientFileId", by.y = "ClientFileId", all.x = TRUE)

  colnames(tmp_donor) <- gsub('DonationMadeToName', 'RecipientName', colnames(tmp_donor), fixed = TRUE)
  colnames(tmp_donor) <- gsub('ReturnClientName', 'DonorName', colnames(tmp_donor), fixed = TRUE)

  # You can't add a new column to an empty data.frame
  if(nrow(tmp_donor) > 0) {
    tmp_donor$ReceiptType <- 'Donation'
  } else {
    message("No donor returns for search: ", donor_name)
  }

  if(donor_only == FALSE) {

    if(approximate == FALSE) {
      tmp_recipient <- returns_receipts_details[grep(donor_name, returns_receipts_details$ReceivedFromClientName),]
    } else {
      tmp_recipient <- returns_receipts_details[agrep(donor_name, returns_receipts_details$ReceivedFromClientName),]
    }
    colnames(tmp_recipient) <- gsub('ReceivedFromClientName', 'DonorName', colnames(tmp_recipient), fixed = TRUE)

    # tmp_ae <- tmp_recipient[tmp_recipient$ReturnTypeCode == 'federalassociatedentity',]

    if(nrow(tmp_recipient) == 0) {
      message("No recipient returns for search: ", donor_name)
    }

    tmp_return <- rbind(tmp_donor[tmp_common_cols], tmp_recipient[tmp_common_cols])

  } else {

    tmp_return <- tmp_donor[tmp_common_cols]

  }

  tmp_return <- tmp_return[order(tmp_return$FinancialYear),]
  rownames(tmp_return) <- NULL

  return(tmp_return)
}

#' Search donor and recipient returns by date
#'
#' This function is simply a wrapper around \code{returns_search()},
#' allowing filtering of results by date.
#'
#' It will eventually be rolled into the former function.
#'
#' @param donor_name Donor name as a regular expression.
#' @param from_date Date in 'YYYY-MM-DD' format.
#' @param ...
#'
#' @return A \code{data.frame}.
#' @export
#'
#' @examples
#' returns_search_date("Woodside|AGL", from_date = "2010-01-01")
returns_search_date <- function(donor_name, from_date, ...) {

  tmp_data <- returns_search(donor_name = donor_name, ...)
  tmp_data <- tmp_data[!is.na(tmp_data$TransactionDate),]
  tmp_data[tmp_data$TransactionDate > from_date,]

}

#' Cross-tab of donations by donor
#'
#' Returns a \code{data.frame} of donations by named donor(s) aggregated by
#' recipient party group and (optionally) year of return.
#'
#' This is mainly a convenience function for the Shiny app.
#'
#' @param donor_name Donor name as a regular expression.
#' @param by_year (\code{BOOL}) Aggregate donation amounts by financial year.
#'   Defaults to \code{FALSE}.
#' @param from_date (Optional) Date in 'YYYY-MM-DD' format.
#' @param approximate (\code{BOOL}) If \code{TRUE}, use \code{agrep} for an
#'   appoximate match, rather than \code{grep}. Defaults to \code{FALSE}
#'   (\code{grep}).
#'
#' @return A \code{data.frame}.
#' @export
#'
#' @examples
#' returns_search_summary("Woodside|AGL", from_date = "2010-01-01", by_year = TRUE)
returns_search_summary <- function(donor_name, by_year = FALSE, from_date = NA, approximate = FALSE) {

  tmp_data <- returns_search(donor_name, approximate = approximate, donor_only = TRUE)

  if(nrow(tmp_data) == 0) {
    stop("No entries returned.")
  }

  if(!is.na(from_date)) {

    tmp_data <- tmp_data[tmp_data$TransactionDate > as.Date(from_date),]

  }

  if(by_year == FALSE) {
    tmp_table <- aggregate(Amount ~ PartyGroupName + DonorName, tmp_data, sum)
  } else {
    tmp_table <- aggregate(Amount ~ FinancialYear + PartyGroupName + DonorName, tmp_data, sum)

  }

  return(tmp_table[order(tmp_table$PartyGroupName),])

}
